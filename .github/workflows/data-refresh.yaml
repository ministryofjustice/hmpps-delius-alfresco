---
name: Alfresco Data Refresh

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment (e.g. preprod)"
        required: true
        default: "preprod"
      days:
        description: "Look-back window in days"
        required: false
        default: "1"

permissions:
  contents: read

jobs:
  find-and-reindex:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: ${{ github.event_name == 'schedule' && fromJson('["poc", "dev", "test", "stage"]') || fromJson(format('["{0}"]', github.event.inputs.environment)) }}
    environment: ${{ matrix.environment }}-preapproved

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: "v1.29.13"

      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: "v3.15.2"

      - name: Install Task
        uses: arduino/setup-task@v2
        with:
          version: 3.x

      - name: Configure kubectl context
        run: |
          echo "${{ secrets.KUBE_CERT }}" > ca.crt
          kubectl config set-cluster ${KUBE_CLUSTER} --certificate-authority=./ca.crt --server="https://${KUBE_CLUSTER}"
          kubectl config set-credentials deploy-user --token="${{ secrets.KUBE_TOKEN }}"
          kubectl config set-context ${KUBE_CLUSTER} --cluster=${KUBE_CLUSTER} --user=deploy-user --namespace="${KUBE_NAMESPACE}"
          kubectl config use-context ${KUBE_CLUSTER}
        env:
          KUBE_NAMESPACE: ${{ secrets.KUBE_NAMESPACE }}
          KUBE_CLUSTER: ${{ secrets.KUBE_CLUSTER }}

      - name: Port-forward to opensearch-proxy and query UUIDs
        id: query
        env:
          DAYS: ${{ github.event.inputs.days }}
        run: |
          set -euo pipefail

          # Find a running opensearch-proxy pod
          POD=$(kubectl get pods -o name | grep opensearch-proxy-cloud-platform | head -n 1)
          if [ -z "${POD}" ]; then
            echo "No opensearch-proxy pod found" >&2
            exit 1
          fi

          # Start port-forward in background
          kubectl port-forward "${POD#pod/}" 8080:8080 >/tmp/pf.log 2>&1 &
          PF_PID=$!
          echo "PF_PID=$PF_PID" >> $GITHUB_OUTPUT
          # Give it a moment
          sleep 3

          # Build query with now-${DAYS}d window
          cat > query-unindexed.json <<'JSON'
          {
            "size": 1000,
            "_source": false,
            "query": {
              "bool": {
                "filter": [
                  { "range": { "cm%3Acreated": { "gte": "REPLACE_NOW_WINDOW" } } }
                ],
                "must": [
                  { "match": { "TYPE": "nspg:offenderDocument" } }
                ],
                "must_not": [
                  { "exists": { "field": "cm%3Acontent" } }
                ]
              }
            },
            "sort": [ { "_id": "desc" } ],
            "track_total_hits": false
          }
          JSON
          sed -i.bak "s/REPLACE_NOW_WINDOW/now-${DAYS}d/" query-unindexed.json

          # Query opensearch-proxy
          curl -sS -X POST "http://localhost:8080/alfresco/_search" \
            --header "Content-Type: application/json" \
            --data-binary @query-unindexed.json \
            -o hits.json

          # Extract UUIDs
          jq -r '.hits.hits[]._id' hits.json | sort -u > uuids.txt || true
          echo "Found $(wc -l < uuids.txt) UUID(s)."
          if [ ! -s uuids.txt ]; then
            echo "no_uuids=true" >> $GITHUB_OUTPUT
          else
            echo "no_uuids=false" >> $GITHUB_OUTPUT
          fi

      - name: Stop port-forward
        if: steps.query.outputs.PF_PID != ''
        run: |
          kill -9 "${{ steps.query.outputs.PF_PID }}" || true

      - name: Map UUIDs -> alf_node.id via ephemeral pod
        if: steps.query.outputs.no_uuids == 'false'
        id: mapids
        run: |
          set -euo pipefail

          # Pull DB details from secret
          JDBC_URL=$(kubectl get secret rds-instance-output -o jsonpath='{.data.RDS_JDBC_URL}' | base64 -d)
          DB_USER=$(kubectl get secret rds-instance-output -o jsonpath='{.data.DATABASE_USERNAME}' | base64 -d)
          DB_PASS=$(kubectl get secret rds-instance-output -o jsonpath='{.data.DATABASE_PASSWORD}' | base64 -d)

          # Parse JDBC URL -> host/port/db
          HOST=$(echo "$JDBC_URL" | sed -E 's#jdbc:postgresql://([^:/]+):([0-9]+)/([^?]+).*#\1#')
          PORT=$(echo "$JDBC_URL" | sed -E 's#jdbc:postgresql://([^:/]+):([0-9]+)/([^?]+).*#\2#')
          DBNM=$(echo "$JDBC_URL" | sed -E 's#jdbc:postgresql://([^:/]+):([0-9]+)/([^?]+).*#\3#')

          # Create ephemeral pod with numeric UID to satisfy runAsNonRoot policy
          kubectl run psql-util \
            --image=ghcr.io/ministryofjustice/hmpps-delius-alfresco-db-utils:latest \
            --restart=Never \
            --overrides='{
              "spec":{
                "securityContext":{"allowPrivilegeEscalation":false,"privileged":false,"runAsNonRoot":true,"runAsUser":999,"capabilities":{"drop":["ALL"]},"seccompProfile":{"type":"RuntimeDefault"}}
              }
            }' \
            -- /bin/sh -lc "sleep 600" >/dev/null 2>&1 || true

          # Wait up to 3 minutes for Ready; if it fails, show why and exit
          if ! kubectl wait --for=condition=Ready pod/psql-util --timeout=180s; then
            echo "Ephemeral pod failed to become Ready. Describing for diagnostics:"
            kubectl describe pod psql-util || true
            kubectl logs psql-util || true
            exit 1
          fi

          # Stream UUIDs into the pod (no kubectl cp needed)
          kubectl exec -i psql-util -- /bin/sh -lc "cat > /tmp/uuids.txt" < uuids.txt

          # Run the mapping using a temp table and \copy
          kubectl exec psql-util -- /bin/sh -c "
            export PGPASSWORD='$DB_PASS';
            psql -h '$HOST' -p '$PORT' -U '$DB_USER' -d '$DBNM' -qAt <<'EOF' > /tmp/query_output.txt
            SET client_min_messages TO WARNING;
            CREATE TEMP TABLE uuids (uuid text);
            \\copy uuids FROM '/tmp/uuids.txt' WITH (format text);
            SELECT id FROM alf_node
            WHERE store_id = 6
              AND uuid IN (SELECT uuid FROM uuids)
            ORDER BY id;
          EOF
          "

          kubectl cp psql-util:/tmp/query_output.txt ./ids.txt

          cat ids.txt

          kubectl delete pod psql-util --grace-period=0 --force >/dev/null 2>&1 || true

          sort -n -u ids.txt -o ids.txt
          echo "Resolved $(wc -l < ids.txt) alf_node id(s)."
          if [ ! -s ids.txt ]; then
            echo "no_ids=true" >> $GITHUB_OUTPUT
          else
            echo "no_ids=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate Helm values for reindex-list
        if: steps.mapids.outputs.no_ids == 'false'
        run: |
          set -euo pipefail
          echo "idList:" > ids.values.yaml
          awk '{print "  - " $0}' ids.txt >> ids.values.yaml
          echo "Generated ids.values.yaml:"
          cat ids.values.yaml

      - name: Clean up previous reindex-list configmaps (static names)
        if: steps.mapids.outputs.no_ids == 'false'
        run: |
          set -euo pipefail
          kubectl delete configmap reindexing-list-configmap --ignore-not-found
          kubectl delete configmap reindexing-list-prefixes-configmap --ignore-not-found

          # Loop through the ids and run the task to delete existing reindex configmaps
          while IFS= read -r id; do
            next_id=$((id + 1))
            task delete_existing_reindex_configmaps_for_range ENV=${{ matrix.environment }} FROM=${id} TO=${next_id}
          done < ids.txt

      - name: Kick off reindex (one container per ID)
        if: steps.mapids.outputs.no_ids == 'false'
        env:
          KUBE_NAMESPACE: ${{ secrets.KUBE_NAMESPACE }}
        run: |
          set -euo pipefail

          OPEN_SEARCH_PREFIX=$(kubectl get svc --namespace ${KUBE_NAMESPACE} | grep 'opensearch-proxy-service-cloud-platform' | awk '{ print $1 }')
          OPENSEARCH_HOST=$(echo "${OPEN_SEARCH_PREFIX}.${KUBE_NAMESPACE}.svc.cluster.local")
          RELEASE="reindex-list-$(openssl rand -hex 4)"
          helm install "$RELEASE" ./jobs/reindex-list \
            --set "global.elasticsearch.host=${OPENSEARCH_HOST}" \
            -f ids.values.yaml \
            --namespace "${KUBE_NAMESPACE}"
          echo "Installed Helm release: $RELEASE"

      - name: Summary
        run: |
          echo "UUIDs (if any):"
          [ -f uuids.txt ] && cat uuids.txt || true
          echo
          echo "alf_node IDs (if any):"
          [ -f ids.txt ] && cat ids.txt || true